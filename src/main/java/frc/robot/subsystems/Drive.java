// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import frc.robot.Config;
import frc.robot.Convert;
import frc.robot.Network;
import frc.robot.PIDConstants;
import frc.robot.commands.DriveManual;

import edu.wpi.first.wpilibj.command.Subsystem;

public class Drive extends Subsystem {

    public WPI_TalonSRX frontRight;
    public WPI_TalonSRX backRight;
    public WPI_TalonSRX frontLeft;
    public WPI_TalonSRX backLeft;

    //state
    private double dkSpeedNeutral = 0.45;
    private double dkSpeedShift = 0.2;
    private double dkSpeed = dkSpeedNeutral;
    private double forward = 0;
    private double turn = 0;

    public Drive() {
        frontRight = new WPI_TalonSRX(2);
        
        backRight = new WPI_TalonSRX(1);
        
        frontLeft = new WPI_TalonSRX(3);
        
        backLeft = new WPI_TalonSRX(4);
        
        //config basic things
        Config.configAllStart(frontRight);
        Config.configAllStart(frontLeft);
        Config.configAllStart(backRight);
        Config.configAllStart(backLeft);
        //config behavior
        backRight.follow(frontRight);
        backLeft.follow(frontLeft);
        frontRight.setInverted(true);
        backRight.setInverted(InvertType.FollowMaster);
        frontLeft.setInverted(false);
        backLeft.setInverted(InvertType.FollowMaster);
        frontRight.configOpenloopRamp(0.15);
        frontLeft.configOpenloopRamp(0.15);
    }

    @Override
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
        setDefaultCommand(new DriveManual());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        checkState();

        arcadeDrive(forward, turn);

        putNetwork();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    private void checkState(){
    }
    private void putNetwork(){
    }

	/**
	 * Basic arcade drive control.
	 * @param forward Percentage forward(-1 to 1).
	 * @param turn Percentage turn(-1 to 1).
	 */
	private void arcadeDrive(double forward, double turn){
		double right = arcadeMath(forward, -turn);
        double left = arcadeMath(forward, turn);
        tankDrive(left,right);
		//dRightF.set(ControlMode.PercentOutput, forward, DemandType.ArbitraryFeedForward, -turn);
		//dLeftF.set(ControlMode.PercentOutput, forward, DemandType.ArbitraryFeedForward, +turn);
	}
	/**
	 * 
	 * @param forward Percentage forward(-1 to 1).
	 * @param turn Percentage turn(-1 to 1).
	 * @param right If this is the right or left side.
	 * @return Desired speed for certain side to perform arcade drive.
	 */
	private double arcadeMath(double forward, double turn){
        return Convert.limit(forward+turn);
	}
	/**
	 * Returns a percentage rpm as native talon units per 100 ms.
	 * @param percentOutput Percentage of range(-1 to 1).
	 * @param range Maximum range of speed(rpm).
	 * @return Native talon units per 100 ms.
	 */
	private double calc100ms(double percentOutput, double range){//percentage rpm as native units
		double tRPM = percentOutput*range;
		return Convert.getNative(tRPM);//talons use sensor units per 100ms(native units)
	}

	/**
	 * Basic tank drive control.
	 * @param left Desired left speed.
	 * @param right Desired right speed.
	 */
    private void tankDrive(double left, double right){
		left*=dkSpeed;
		right*=dkSpeed;
		setDrive(left, right);
    }

    //interaction
    public double getDriveSpeed(){
        return dkSpeed;
    }

    /**
     * Increases speed(max one shift up of neutral)
     */
    public void shiftUp(){
        double max = dkSpeedNeutral+dkSpeedShift;
        dkSpeed=Math.min(dkSpeed+dkSpeedShift, max); 
    }
    /**
     * Decreases speed(min one shift down of neutral)
     */
    public void shiftDown(){
        double min = dkSpeedNeutral-dkSpeedShift;
        dkSpeed=Math.max(dkSpeed-dkSpeedShift, min); 
    }
    /**
     * Manually sets speed(0-1 or 0-100%)
     * @param speed Percentage speed
     */
    public void shiftSet(double speed){
        dkSpeed=Convert.limit(0,1,speed);
    }
    
    /**
     * Sets the target forward speed
     * @param _forward Percentage forward
     */
    public void setForward(double _forward){
        forward=_forward;
    }
    /**
     * Sets the target turn speed
     * @param _turn Percentage turn
     */
    public void setTurn(double _turn){
        turn=_turn;
    }

    /**
     * Manually set the drivebase in simple Percentage operation(tankdrive).
     * @param left Left-side percentage output.
     * @param right Right-side percentage output.
     */
    public void setDrive(double left, double right){
		frontRight.set(ControlMode.PercentOutput, right);
		frontLeft.set(ControlMode.PercentOutput, left);
    }

}

